// This file is generated by 'rules_db_create.py' from 'Rules.md'.
// Please don't edit it

#include "rules.h"

#include <QString>

namespace verapp
{

namespace rules
{

void initDb(QString* titles, QString* explanations)
{

titles[type("F001")] = "Source files should not use the '\\\\r' (CR) character";
explanations[type("F001")] =
"<html>"
"F001: Source files should not use the &apos;\\\\r&apos; (CR) character"
"<hr>"
"As a commonly accepted practice, line breaks are denoted by a single &apos;\\\\n&apos; (LF) character or by two characters &quot;\\\\r\\\\n&quot; (CRLF). A single appearance of &apos;\\\\r&apos; (CR) is discouraged."
"<br><br>"
"<b>Compliance:</b> Boost"
"</html>";

titles[type("F002")] = "File names should be well-formed";
explanations[type("F002")] =
"<html>"
"F002: File names should be well-formed"
"<hr>"
"The source file names should be well-formed in the sense of their allowed maximum length and directory depth. Directory and file names should start with alphabetic character or underscore. In addition, directory names should not contain dots and file names can have only one dot. <b>Recognized parameters:</b>"
"<pre>"
"    Name                    Default   Description\n"
"    ----------------------- --------- -------------------------------------------------\n"
"    max-directory-depth     8         Maximum depth of the directory structure.\n"
"    max-dirname-length      31        Maximum length of the directory path component.\n"
"    max-filename-length     31        Maximum length of the leaf file name.\n"
"    max-path-length         100       Maximum length of the full path."
"</pre>"
"<b>Compliance:</b> Boost"
"</html>";

titles[type("L001")] = "No trailing whitespace";
explanations[type("L001")] =
"<html>"
"L001: No trailing whitespace"
"<hr>"
"<i>Trailing whitespace* is any whitespace character (space or tab) that is placed at the end of the source line, after other characters or alone. The presence of *trailing whitespace</i> artificially influences some source code metrics and is therefore discouraged. As a special case, the trailing whitespace in the otherwise empty lines is allowed provided that the amount of whitespace is identical to the indent in the previous line - this exception is more friendly with less smart editors, but can be switched off by setting non-zero value for the `strict-trailing-space` parameter. <b>Recognized parameters:</b>"
"<pre>"
"    Name                      Default   Description\n"
"    ------------------------- --------- --------------------------------------\n"
"    strict-trailing-space     0         Strict mode for trailing whitespace."
"</pre>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("L002")] = "Don't use tab characters";
explanations[type("L002")] =
"<html>"
"L002: Don&apos;t use tab characters"
"<hr>"
"<i>Horizontal tabs</i> are not consistently handled by editors and tools. Avoiding them ensures that the intended formatting of the code is preserved."
"<br><br>"
"<b>Compliance:</b> HICPP, JSF"
"</html>";

titles[type("L003")] = "No leading and no trailing empty lines";
explanations[type("L003")] =
"<html>"
"L003: No leading and no trailing empty lines"
"<hr>"
"<i>Leading and trailing empty lines</i> confuse users of various tools (like `head` and `tail`) and artificially influence some source code metrics."
"<br><br>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("L004")] = "Line cannot be too long";
explanations[type("L004")] =
"<html>"
"L004: Line cannot be too long"
"<hr>"
"The source code line should not exceed some <i>reasonable</i> length. <b>Recognized parameters:</b>"
"<pre>"
"    Name                Default   Description\n"
"    ------------------- --------- -------------------------------------\n"
"    max-line-length     100       Maximum length of source code line."
"</pre>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("L005")] = "There should not be too many consecutive empty lines";
explanations[type("L005")] =
"<html>"
"L005: There should not be too many consecutive empty lines"
"<hr>"
"The empty lines (if any) help to introduce more &quot;light&quot; in the source code, but they should not be overdosed in the sense that too many consecutive empty lines make the code harder to follow. Lines containing only whitespace are considered to be empty in this context. <b>Recognized parameters:</b>"
"<pre>"
"    Name                            Default   Description\n"
"    ------------------------------- --------- --------------------------------------------\n"
"    max-consecutive-empty-lines     2         Maximum number of consecutive empty lines."
"</pre>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("L006")] = "Source file should not be too long";
explanations[type("L006")] =
"<html>"
"L006: Source file should not be too long"
"<hr>"
"The source file should not exceed a <i>reasonable</i> length. Long source files can indicate an opportunity for refactoring. <b>Recognized parameters:</b>"
"<pre>"
"    Name                Default   Description\n"
"    ------------------- --------- ------------------------------------\n"
"    max-file-length     2000      Maximum number of lines in a file."
"</pre>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("T001")] = "One-line comments should not have forced continuation";
explanations[type("T001")] =
"<html>"
"T001: One-line comments should not have forced continuation"
"<hr>"
"The one-line comment is a comment that starts with `//`. The usual intent is to let the comment continue till the end of the line, but the preprocessing rules of the language allow to actually continue the comment in the next line if <i>line-splicing</i> is forced with the backslash at the end of the line:"
"<pre>"
"void foo()\n"
"{\n"
"    // this comment is continued in the next line \\\n"
"    exit(0);\n"
"}"
"</pre>"
"It is not immediately obvious what happens in this example. Moreover, the line-splicing works only if the backslash is really the last character in the line - which is error prone because any white characters that might appear after the backslash will change the meaning of the program without being visible in the code."
"<br><br>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("T002")] = "Reserved names should not be used for preprocessor macros";
explanations[type("T002")] =
"<html>"
"T002: Reserved names should not be used for preprocessor macros"
"<hr>"
"The C++ Standard reserves some forms of names for language implementations. One of the most frequent violations is a definition of preprocessor macro that begins with underscore followed by a capital letter or containing two consecutive underscores:"
"<pre>"
"#define _MY_MACRO something\n"
"#define MY__MACRO something"
"</pre>"
"Even though the majority of known compilers use more obscure names for internal purposes and the above code is not likely to cause any significant problems, all such names are <i>formally reserved</i> and therefore should not be used. Apart from the use of underscore in macro names, preprocessor macros should not be used to redefine language keywords:"
"<pre>"
"#define private public\n"
"#define const"
"</pre>"
"<b>Compliance:</b> ISO"
"</html>";

titles[type("T003")] = "Some keywords should be followed by a single space";
explanations[type("T003")] =
"<html>"
"T003: Some keywords should be followed by a single space"
"<hr>"
"Keywords from the following list: -   `case` -   `class` -   `delete` -   `enum` -   `explicit` -   `extern` -   `goto` -   `new` -   `struct` -   `union` -   `using` should be followed by a single space for better readability."
"<br><br>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("T004")] = "Some keywords should be immediately followed by a colon";
explanations[type("T004")] =
"<html>"
"T004: Some keywords should be immediately followed by a colon"
"<hr>"
"Keywords from the following list: -   `default` -   `private` -   `protected` -   `public` should be immediately followed by a colon, unless used in the list of base classes:"
"<pre>"
"class A : public B, private C\n"
"{\n"
"public:\n"
"     A();\n"
"     ~A();\n"
"protected:\n"
"     // ...\n"
"private:\n"
"     // ...\n"
"};\n"
"void fun(int a)\n"
"{\n"
"     switch (a)\n"
"     {\n"
"     // ...\n"
"     default:\n"
"          exit(0);\n"
"     }\n"
"}"
"</pre>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("T005")] = "Keywords break and continue should be immediately followed by a semicolon";
explanations[type("T005")] =
"<html>"
"T005: Keywords break and continue should be immediately followed by a semicolon"
"<hr>"
"The `break` and `continue` keywords should be immediately followed by a semicolon, with no other tokens in between:"
"<pre>"
"while (...)\n"
"{\n"
"     if (...)\n"
"     {\n"
"          break;\n"
"     }\n"
"     if (...)\n"
"     {\n"
"          continue;\n"
"     }\n"
"     // ...\n"
"}"
"</pre>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("T006")] = "Keywords return and throw should be immediately followed by a semicolon or a single space";
explanations[type("T006")] =
"<html>"
"T006: Keywords return and throw should be immediately followed by a semicolon or a single space"
"<hr>"
"The `return` and `throw` keywords should be immediately followed by a semicolon or a single space:"
"<pre>"
"void fun()\n"
"{\n"
"     if (...)\n"
"     {\n"
"          return;\n"
"     }\n"
"     // ...\n"
"}\n"
"int add(int a, int b)\n"
"{\n"
"     return a + b;\n"
"}"
"</pre>"
"An exception to this rule is allowed for exeption specifications:"
"<pre>"
"void fun() throw();"
"</pre>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("T007")] = "Semicolons should not be isolated by spaces or comments from the rest of the code";
explanations[type("T007")] =
"<html>"
"T007: Semicolons should not be isolated by spaces or comments from the rest of the code"
"<hr>"
"The semicolon should not stand isolated by whitespace or comments from the rest of the code."
"<pre>"
"int a ;     // bad\n"
"int b\n"
";           // bad\n"
"int c;      // OK"
"</pre>"
"As an exception from this rule, semicolons surrounded by spaces are allowed in `for` loops:"
"<pre>"
"for ( ; ; ) // OK as an exception\n"
"{\n"
"    // ...\n"
"}"
"</pre>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("T008")] = "Keywords catch, for, if, switch and while should be followed by a single space";
explanations[type("T008")] =
"<html>"
"T008: Keywords catch, for, if, switch and while should be followed by a single space"
"<hr>"
"Keywords `catch`, `for`, `if`, `switch` and `while` should be followed by a single space and then an opening left parenthesis:"
"<pre>"
"catch (...)\n"
"{\n"
"     for (int i = 0; i != 10; ++i)\n"
"     {\n"
"          if (foo(i))\n"
"          {\n"
"               while (getline(cin, line))\n"
"               {\n"
"                    switch (i % 3)\n"
"                    {\n"
"                    case 0:\n"
"                         bar(line);\n"
"                         break;\n"
"                    // ...\n"
"                    }\n"
"               }\n"
"          }\n"
"     }\n"
"}"
"</pre>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("T009")] = "Comma should not be preceded by whitespace, but should be followed by one";
explanations[type("T009")] =
"<html>"
"T009: Comma should not be preceded by whitespace, but should be followed by one"
"<hr>"
"A comma, whether used as operator or in various lists, should not be preceded by whitespace on its left side, but should be followed by whitespace on its right side:"
"<pre>"
"void fun(int x, int y, int z);\n"
"int a[] = {5, 6, 7};\n"
"class A : public B,\n"
"          public C\n"
"{\n"
"     // ...\n"
"};"
"</pre>"
"An exception to this rule is allowed for `operator,`:"
"<pre>"
"struct A {};\n"
"void operator,(const A &amp;left, const A &amp;right);"
"</pre>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("T010")] = "Identifiers should not be composed of 'l' and 'O' characters only";
explanations[type("T010")] =
"<html>"
"T010: Identifiers should not be composed of &apos;l&apos; and &apos;O&apos; characters only"
"<hr>"
"The characters &apos;l&apos; (which is lowercase &apos;L&apos;) and &apos;O&apos; (which is uppercase &apos;o&apos;) should not be the only characters used in the identifier, because this would make them visually similar to numeric literals."
"<br><br>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("T011")] = "Curly brackets from the same pair should be either in the same line or in the same column";
explanations[type("T011")] =
"<html>"
"T011: Curly brackets from the same pair should be either in the same line or in the same column"
"<hr>"
"Corresponding curly brackets should be either in the same line or in the same column. This promotes clarity by emphasising scopes, but allows concise style of one-line definitions and empty blocks:"
"<pre>"
"class MyException {};\n"
"struct MyPair\n"
"{\n"
"    int a;\n"
"    int b;\n"
"};\n"
"enum state { close, open };\n"
"enum colors\n"
"{\n"
"    black,\n"
"    red,\n"
"    green,\n"
"    blue,\n"
"    white\n"
"};"
"</pre>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("T012")] = "Negation operator should not be used in its short form";
explanations[type("T012")] =
"<html>"
"T012: Negation operator should not be used in its short form"
"<hr>"
"The negation operator (exclamation mark) reduces readability of the code due to its terseness. Prefer explicit logical comparisons or alternative tokens for increased readability:"
"<pre>"
"if (!cond)         // error-prone\n"
"if (cond == false) // better\n"
"if (not cond)      // better (alternative keyword)"
"</pre>"
"<b>Compliance:</b> Inspirel"
"</html>";

titles[type("T013")] = "Source files should contain the copyright notice";
explanations[type("T013")] =
"<html>"
"T013: Source files should contain the copyright notice"
"<hr>"
"The copyright notice is required by man coding standards and guidelines. In some countries every written artwork has some copyright, even if implicit. Prefer explicit notice to avoid any later confusion. This rule verifies that at least one comment in the source file contains the &quot;copyright&quot; word."
"<br><br>"
"<b>Compliance:</b> Boost"
"</html>";

titles[type("T014")] = "Source files should refer the Boost Software License";
explanations[type("T014")] =
"<html>"
"T014: Source files should refer the Boost Software License"
"<hr>"
"The Boost Software License should be referenced in the source code. This rule verifies that at least one comment in the source file contains the &quot;Boost Software License&quot; phrase. Note that this rule is very specific to the Boost libraries and those project that choose to use the Boost license. It is therefore not part of the default profile."
"<br><br>"
"<b>Compliance:</b> Boost"
"</html>";

titles[type("T015")] = "HTML links in comments and string literals should be correct";
explanations[type("T015")] =
"<html>"
"T015: HTML links in comments and string literals should be correct"
"<hr>"
"The links embedded in comments and string literals should have correct form and should reference existing files."
"<br><br>"
"<b>Compliance:</b> Boost"
"</html>";

titles[type("T016")] = "Calls to min/max should be protected against accidental macro substitution";
explanations[type("T016")] =
"<html>"
"T016: Calls to min/max should be protected against accidental macro substitution"
"<hr>"
"The calls to min and max functions should be protected against accidental macro substitution."
"<pre>"
"x = max(y, z); // wrong, vulnerable to accidental macro substitution\n"
"x = (max)(y, z); // OK\n"
"x = max BOOST_PREVENT_MACRO_SUBSTITUTION (y, z); // OK"
"</pre>"
"<b>Compliance:</b> Boost"
"</html>";

titles[type("T017")] = "Unnamed namespaces are not allowed in header files";
explanations[type("T017")] =
"<html>"
"T017: Unnamed namespaces are not allowed in header files"
"<hr>"
"Unnamed namespaces are not allowed in header files. The typical use of unnamed namespace is to hide module-internal names from the outside world. Header files are physically concatenated in a single translation unit, which logically merges all namespaces with the same name. Unnamed namespaces are also merged in this process, which effectively undermines their initial purpose. Use named namespaces in header files. Unnamed namespaces are allowed in implementation files only."
"<br><br>"
"<b>Compliance:</b> Boost"
"</html>";

titles[type("T018")] = "Using namespace is not allowed in header files";
explanations[type("T018")] =
"<html>"
"T018: Using namespace is not allowed in header files"
"<hr>"
"Using namespace directives are not allowed in header files. The using namespace directive imports names from the given namespace and when used in a header file influences the global namespace of all the files that directly or indirectly include this header file. It is imaginable to use the using namespace directive in a limited scope in a header file (for example in a template or inline function definition), but for the sake of consistency this is also discouraged."
"<br><br>"
"<b>Compliance:</b> C++ Coding Standards"
"</html>";

titles[type("T019")] = "Control structures should have complete curly-braced block of code";
explanations[type("T019")] =
"<html>"
"T019: Control structures should have complete curly-braced block of code"
"<hr>"
"Control structures managed by for, if and while constructs can be associated with a single instruction or with a complex block of code. Standardizing on the curly-braced blocks in all cases allows one to avoid common pitfalls and makes the code visually more uniform."
"<pre>"
"if (x) foo();     // bad style\n"
"if (x) { foo(); } // OK\n"
"if (x)\n"
"    foo();        // again bad style\n"
"if (x)\n"
"{                 // OK\n"
"    foo();\n"
"}\n"
"if (x)\n"
"    while (y)     // bad style\n"
"        foo();    // bad style\n"
"if (x)\n"
"{                 // OK\n"
"    while (y)\n"
"    {             // OK\n"
"        foo();\n"
"    }\n"
"}\n"
"for (int i = 0; i &lt;= 10; ++i);  // oops!\n"
"    cout &lt;&lt; &quot;Hello\\n&quot;;\n"
"for (int i = 0; i &lt;= 10; ++i)   // OK\n"
"{\n"
"    cout &lt;&lt; &quot;Hello\\n&quot;;\n"
"}"
"</pre>"
"<b>Compliance:</b> Inspirel"
"</html>";

}

}

}
